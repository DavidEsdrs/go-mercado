// The following package was generated by Claude 3.5 Sonnet (amazing...)
package logger

import (
	"fmt"
	"io"
	"os"
	"runtime"
	"sync"
	"time"
)

type Level int

const (
	DEBUG Level = iota
	INFO
	WARN
	ERROR
	FATAL
)

func (l Level) String() string {
	return [...]string{"DEBUG", "INFO", "WARN", "ERROR", "FATAL"}[l]
}

type Flag int

const (
	Ldate Flag = 1 << iota
	Ltime
	Lmicroseconds
	Llongfile
	Lshortfile
	LUTC
	Lmsgprefix
	LstdFlags = Ldate | Ltime
)

type Logger struct {
	mu     sync.Mutex
	out    io.Writer
	prefix string
	flag   Flag
	level  Level
}

func New(out io.Writer, prefix string, flag Flag) *Logger {
	return &Logger{out: out, prefix: prefix, flag: flag, level: INFO}
}

func (l *Logger) SetLevel(level Level) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.level = level
}

func (l *Logger) log(level Level, format string, v ...interface{}) {
	if level < l.level {
		return
	}

	l.mu.Lock()
	defer l.mu.Unlock()

	var buf []byte

	// Add timestamp
	if l.flag&(Ldate|Ltime|Lmicroseconds) != 0 {
		buf = append(buf, l.formatHeader()...)
	}

	// Add prefix
	if l.prefix != "" {
		buf = append(buf, l.prefix...)
		buf = append(buf, ": "...)
	}

	// Add log level
	buf = append(buf, "["+level.String()+"] "...)

	// Add caller info
	if l.flag&(Lshortfile|Llongfile) != 0 {
		buf = append(buf, l.caller()...)
	}

	// Add message
	buf = append(buf, fmt.Sprintf(format, v...)...)
	if len(buf) == 0 || buf[len(buf)-1] != '\n' {
		buf = append(buf, '\n')
	}

	l.out.Write(buf)
}

func (l *Logger) formatHeader() []byte {
	// Implement timestamp formatting based on flags
	// This is a simplified version
	return []byte(time.Now().Format("2006/01/02 15:04:05 "))
}

func (l *Logger) caller() string {
	_, file, line, ok := runtime.Caller(3) // Skip 3 frames to get to the caller
	if !ok {
		return "???:0 "
	}
	if l.flag&Lshortfile != 0 {
		short := file
		for i := len(file) - 1; i > 0; i-- {
			if file[i] == '/' {
				short = file[i+1:]
				break
			}
		}
		file = short
	}
	return fmt.Sprintf("%s:%d ", file, line)
}

func (l *Logger) Debug(format string, v ...interface{}) {
	l.log(DEBUG, format, v...)
}

func (l *Logger) Info(format string, v ...interface{}) {
	l.log(INFO, format, v...)
}

func (l *Logger) Warn(format string, v ...interface{}) {
	l.log(WARN, format, v...)
}

func (l *Logger) Error(format string, v ...interface{}) {
	l.log(ERROR, format, v...)
}

func (l *Logger) Fatal(format string, v ...interface{}) {
	l.log(FATAL, format, v...)
	os.Exit(1)
}
